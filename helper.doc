                Access MongoDB via docker container:
                
You can connect using mongo shell:
    - docker exec -it mongo mongosh
* docker exec -it mongo -> Open terminal inside the container
* mongosh -> start MongoDB shell

1. List Databases
    - show dbs
2. Switch to a Database
    - use products
3. List Collections (Tables)
    - show collections
4. Query Documents (Rows)
    - db.products.find()
Example output:
    {
    "_id": ObjectId("693d3cc3039e4f9e29c6a9e7"),
    "name": "Laptop",
    "price": 1200,
    "quantity": 10,
    "createdAt": ISODate("2025-12-13T17:15:31.593Z")
    }

5. Insert Documents (Add a Row)
    db.products.insertOne({
        name: "Mac...",
        price: 200..,
        quantity: 5,
        createdAt: new Date()
    })

6. Update Documents
    db.prodcuts.updateOne({
        { name: "Labtop" },
        { $set: { price: 1300 } }
    })
* $set :update specific fields.

7. Delete Documents
    - db.prooducts.deleteOne({ name: "Mac M6" })


            Apply Distributed System with Microservies 

    This project apply Distributed-System it consists of independently 
  deployment microservice that communicate over HTTP and RabbitMQ, use separate
  database, and are coordination throught an API Gateway with fault isolation.

1. Have multiple independent services:
    - api-gateway
    - user-service
    - product-service
    - task-service
    - payment-service
    - notification-service
Each service:
- Runs in its own process
- Has its own port
- Has its own responsibility


2. Network-Based Communication
    HTTP (Synchronous)

    API Gateway -> User/ Product/ Task/ Payment service
    
        Using: 
            - http-proxy-middleware
            - Docker service name (user-service, payment-service..)


3. Asynchronouse Messaging (RabbitMQ)
    Payment Service:

        channel.sendToQueue("Payment_Created", ...)
    
    Notification Service:

        channel.consume("Payment_Created",...)
        
        + Services do NOT call each other directl
        + Event-dirven communication
        + Loose conpuling
        This is classis distributed-system design.

4. independent Database (Distributed Data)
    - MongoDB for payment-service
    - Other service have their own dbs


5. Fault Isolation
 Example:
 - Notification service goes down ❌
 - Payment service still saves data ✅
 - Other service continue working ✅
 Even Added:
 - RabbitMQ retry logic
 - Timeouts in API Gateway
 This is fault tolerance, a key distributed-system property.


6. API Gateway Pattern 

    Client -> API Gateway -> Service
    
 - Single entry point
 - Central Routing
 - Hides internal service
 This is a distributed coordination pattern.


7. Containerized Deployment (Docker)
    Using:
    - docker
    - docker-compose
    - Shared Docker network
    Service can run on:
    - Same machine
    - Different machines (cloud)
This make the system physically distributed



    ---Update doc product-service
    
    Example production JSON (Postman)
    {
        "name": "Oversized T-Shirt",
        "description": "Cotton oversized fit",
        "imageUrl": "https://example.com/images/shirt1.png",
        "category": "Shirt",
        "price": 29.99,
        "quantity": 50
    }

    --- Update doc user-service
    
    Before it has name and email only just we will add:
    - Password
    - Hash password (bcrypt)
    - Login endPoint
    - JWT token

        Install dependencies (user-service)
            npm install bcryptjs jsonwebtoken
        
        install dependencies cors
        npm i cors

    bcrypt.hash(password, 10);
    
    - bcrypt.hash(...) : The core function that perform the encryption
    - password : The first argument; this is the actual plain-text password
    (e.g., "mySecret123") provided by the user
    - 10 : The second argument, known as salt rounds. it determines how much
    computational power is used to hash the password. A value of 10 is a standard
    balance between high security and fast performance in 2025.

    +process bcrypt.hash working

    When user input password: 123

    - It transforms 123 into a secure hash: The function takes 
    the simple string "123" and converts it into a long, complex string 
    (e.g., $2b$10$m0mq4PYOOvm74Gukml4FN...).

    - Even short passwords become fixed-length hashes: Regardless of 
    whether your input is 123 or a 50-character phrase, the resulting hash will 
    always be the same length (typically 60 characters for bcrypt).

    - Unique result every time: Because bcrypt automatically
     adds a unique "salt" (random data) to every hash, 
     if you hash 123 twice, you will get two completely different-looking hashes. 
    






    